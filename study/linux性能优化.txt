性能指标：高吞吐(QPS,TPS)和低延迟(RT)


平均负载：系统处于可运行状态和不可中断状态的平均进程数，这里的平均指单位时间内活跃进程数
	可运行状态的进程--正在使用CPU或者正在等待CPU的进程
	不可中断状态的进程--正处于内核态关键流程中的进程，并且这些流程是不可打断的，如等待硬件设备的I/O响应

	监控指标：当平均负载高于CPU数量70%

	排查方案：
	1.uptime查看当前平均负载情况
	2.watch -d uptime查看平均负载的变化情况
	3.mpstat -P ALL 5，监控所有CPU，间隔5秒后输出CPU使用率的变化。判断是大量使用cpu或者等待 CPU 的进程调度，还是I/O等待。
	4.pidstat -u 5 1，间隔5秒输出进程cpu使用率。判断哪些进程引起的。

	top // 查看进程cpu、内存的使用率
	ps aux --sort=-%cpu // CPU 使用率从高到低排序显示进程
	free -m // 查看系统的内存使用情况，包括总内存、已用内存、空闲内存等
	iostat // 查看磁盘的 %util（磁盘利用率）接近 100%，磁盘的读写速度等
	sar -u// 查看 CPU 的历史使用情况
	sar -d // 查看磁盘的历史 I/O 情况

cpu上下文切换(寄存器、内核栈以及虚拟内存等数据的保存和恢复上)
 进程切换：
   1.为了保证所有进程可以得到公平调度，CPU时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被  系统挂起，切换到其它正在等待 CPU 的进程运行。
   2.进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
   3.当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。
   4.当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
   5.发生硬件中断时，CPU上的进程会被中断挂起，转而执行内核中的中断服务程序。
 线程切换：只需要切换线程的私有数据、寄存器等不共享的数据。
 中断上下文切换：为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。
 	只包括内核态中断服务程序执行所必需的状态，包括CPU 寄存器、内核堆栈、硬件中断参数等。

 排查系统上下文切换
  vmstat 5 每隔5秒输出，分析系统的内存，CPU 上下文切换和中断的次数使用情况
   cs（context switch）是每秒上下文切换的次数。
   in（interrupt）则是每秒中断的次数。
   r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待CPU的进程数。
   b（Blocked）则是处于不可中断睡眠状态的进程数。

  pidstat -w 5 输出进程切换指标
  pidstat -wt 1 输出线程的上下文切换指标

   cswch 自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。
   nvcswch 非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。

  如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题
  watch -d cat /proc/interrupts 参数表示高亮显示变化的区域，查看中断情况

CPU使用率
 cat /proc/stat | grep ^cpu 使用man proc可以查看每列的名字
 user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。
 nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。
 system（通常缩写为sys），代表内核态 CPU 时间。
 idle（通常缩写为id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。
 iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。
 irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。
 softirq（通常缩写为 si），代表处理软中断的 CPU 时间。
 steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。
 guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。
 guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。

 使用 perf 分析 CPU 性能问题
  1.常见用法是 perf top或perf top -g开启调用关系的采样，实时显示占用 CPU 时钟最多的函数或者指令，可以用来查找热点函数
   缺点：不保存数据，也就无法用于离线或者后续的分析
  2.perf record 和 perf report，提供了保存数据的功能，保存后的数据，需要你用 perf report 解析

 CPU总使用率高，却找不到对应的进程
  可能发生的场景：1.应用里直接调用了其他二进制程序，运行时间比较短。 2.应用本身在不停地崩溃重启
  # 记录性能事件，等待大约15秒后按 Ctrl+C 退出
  perf record -g

  # 查看报告 通过事件重放，观察日志
  perf report
  pstree | grep processName 用树状形式显示所有进程之间的关系

出现大量不可中断进程和僵尸进程
 进程状态：运行（R）、空闲（I）、不可中断睡眠（D）、可中断睡眠（S）、僵尸（Z）以及暂停（T）
 dstat 1 10 同时查看 CPU 和 I/O 这两种资源的使用情况
 pidstat -d 1 20 查看进程的 I/O 使用情况
 1.strace -p 6082 跟踪进程系统调用
 2.perf record -g
   perf report

中断
 Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：
 上半部(硬中断)用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。
 下半部(软中断)用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。软中断内核线程，名字为 “ksoftirqd/CPU编号”

 
 /proc/softirqs 提供了软中断的运行情况；
 /proc/interrupts 提供了硬中断的运行情况。












