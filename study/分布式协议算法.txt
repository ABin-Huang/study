算法基石：拜占庭容错算法，解决共识问题，不能最优选择策略以及性能问题

acid理论
 是传统数据库常用的设计理念，追求强一致性模型，通过原子性、隔离性、持久性实现数据一致性

BASE理论
 是对 CAP 中一致性和可用性权衡的结果，源于大规模互联网分布式系统实战的总结，基于CAP定理逐步演化而来
 核心思想是不推荐实现事务或强一致性，鼓励可用性和性能优先。根据业务场景特点，使用各种方案实现弹性的基本可用，
 以及数据的最终一致性。在NoSQL中广泛应用，是其系统设计的理论支撑。

1.有几种分布式事务
 柔性事务，基于base理论；刚性事务，基于cap，acid理论

2.如何实现最终一致性
 1)读时修复: 在读取数据时，检测数据的不一致，进行修复
 2)写时修复: 在写入数据，检测数据的不一致时(写操作的失败错误，发现不一致，然后通过重传修复数据的不一致)，进行修复，推荐同时实现自定义写一致性级别比如 All、Quorum、One、Any
 3)异步修复: 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复
 对比上述方案，推荐写时修复，不需要做数据一致性对比，性能消耗比较低

3.分布式共识Paxos
 当前最常用的一批共识算法都是基于它改进的，Fast Paxos 算法、Cheap Paxos 算法、Raft 算法等
 Paxos算法包含2个部分
  1)Basic Paxos 算法，描述的是多节点之间如何就某个值（提案 Value）达成共识；
  2)Multi-Paxos 思想，描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。

4.Basic Paxos 的原理
 Basic Paxos 只能就单个值（Value）达成共识，一旦遇到为一系列的值实现共识的时候，它就不管用了

 提议者（Proposer）: 提议一个值，用于投票表决
 接受者（Acceptor）: 对每个提议的值进行投票，并存储接受的值
 学习者（Learner）: 被告知投票的结果，接受达成共识的值，存储保存，不参与投票的过程。一般来说，学习者是数据备份节点

 二阶段提交，进行共识协商
 1）准备阶段：提议者只将提案编号发送给接收者，接收者只能接受不小于该提案编号的信息，接收到大多数准备响应的提议者，才能发起接受请求进入第二阶段
 2）接受阶段：接受者最终接受最大提案编号携带的值
 3）当接受者通过了一个提案时，就通知给所有的学习者。当学习者发现大多数的接受者都通过了某个提案，那么它也通过该提案，接受该提案的值

 提案编号的大小代表着优先级，根据提案编号的大小，接受者保证三个承诺
 1）准备请求的提案编号，小于等于接受者已经响应的准备请求的提案编号，那么接受者将承诺不响应这个准备请求
 2）接受请求中的提案的提案编号，小于接受者已经响应的准备请求的提案编号，那么接受者将承诺不通过这个提案
 3）接受者之前有通过提案，那么接受者将承诺，会在准备请求的响应中，包含已经通过的最大编号的提案信息。通过告知提议者之前已经通过的最大编号的提案，
    提议者可以知道是否有冲突的提案需要处理。

5.chubby的Multi-Paxos算法
 解决一系列的值实现共识问题，每接收到一个值时，就执行一次 Basic Paxos 算法
 执行多次执行 Basic Paxos会存在几个问题
  1)如果多个提议者同时提交提案，可能出现因为提案编号冲突，在准备阶段没有提议者接收到大多数准备响应，协商失败，需要重新协商。你想象一下，
   一个 5 节点的集群，如果 3 个节点作为提议者同时提案，就可能发生因为没有提议者接收大多数响应（比如 1 个提议者接收到 1 个准备响应，
   另外 2 个提议者分别接收到 2 个准备响应）而准备失败，需要重新协商。
  2)2 轮 RPC 通讯（准备阶段和接受阶段）往返消息多、耗性能、延迟大。你要知道，分布式系统的运行是建立在 RPC 通讯的基础之上的，因此，
   延迟一直是分布式系统的痛点，是需要我们在开发分布式系统时认真考虑和优化的。

 如何解决上述问题，引入领导者和优化 Basic Paxos 执行
  1）通过引入主节点，实现领导者节点作为唯一提议者，这样就不存在多个提议者同时提交提案的情况，也就不存在提案冲突的情况，通过执行 Basic Paxos 算法，进行投票选举产生的
  2）由于领导者处于稳定状态，可以省掉准备阶段，直接进入接受阶段。因为不再需要通过准备请求来发现之前被大多数节点通过的提案，领导者可以独立指定提案中的值
  3）主节点会通过不断续租的方式来延长租期（Lease）。如果主节点故障了，那么其他的节点又会投票选举出新的主节点，也就是说主节点是一直存在的，而且是唯一的。

 缺点：为了实现了强一致性，读操作也只能在主节点上执行，所有的读请求和写请求都由主节点来处理

6.Raft算法
 Raft 算法属于 Multi-Paxos 算法，是现在分布式系统开发首选的共识算法。从本质上说，Raft 算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致
 三个重要步骤：
 领导者选举、
 日志复制：处理写请求的过程就是一个复制和应用（Apply）日志项到状态机的过程
  日志项格式包含用户数据（Command）、索引值（Log index）、任期编号（Term）
  日志复制消息格式包含当前要复制的日志项PrevLogEntry、当前要复制的日志项PrevLogTerm
  1.领导者进入第一阶段，通过日志复制（AppendEntries）RPC 消息，将日志项复制到集群其他节点上
  2.领导者接收到大多数的“复制成功”响应后，它将日志项应用到它的状态机，并返回成功给客户端; 否则返回错误给客户端
  3.follow节点接受日志后并不会马上将日志项应用到状态机，而是通过日志复制 RPC 消息或心跳消息实现，消息中包含了当前最大的，将会被提交（Commit）的日志项索引值
   这个优化，降低了处理客户端请求的延迟，将二阶段提交优化为了一段提交，降低了一半的消息延迟

  当follow节点落后日志复制时
   1.领导者通过日志复制 RPC 消息，发送当前最新日志项到跟随者
   2.跟随者在它的日志中，找不到匹配的PrevLogEntry和PrevLogTerm，发现日志同步不一致，拒绝接收新的日志项，并返回失败信息给领导者
   3.领导者会递减要复制的日志项的索引值，并发送新的日志项到该跟随者，重复2，3步骤知道匹配为止
   4.随者在它的日志中能匹配上，将日志应用到状态机
 成员变更(Raft 算法中唯一被优化和改进的部分)：领导者选举，建立在“大多数”的基础之上，集群成员发生了变化，可能同时存在新旧配置的 2 个“大多数”，出现 2 个领导者。
  两种方式：联合共识（Joint Consensus）、单节点变更（single-server changes）
  核心概念：配置，表示集群是哪些节点组成的，是集群各节点地址信息的集合
  单节点变更方式
   1.领导者（节点 A）向新节点（节点 D）同步数据；
   2.领导者（节点 A）将新配置[A, B, C, D]作为一个日志项，复制到新配置中所有节点（节点 A、B、C、D）上，然后将新配置的日志项应用（Apply）到本地状态机，完成单节点变更。
   缺点：在分区错误、节点故障等情况下，如果我们并发执行单节点变更，那么就可能出现一次单节点变更尚未完成，新的单节点变更又在执行，导致集群出现 2 个领导者的情况
   解决方案：开启NO_OP日志项，作用是作为一个“同步信号”，确保领导者和追随者在执行关键操作之前处于一致的状态。只有在NO_OP日志项应用后，才执行成员变更请求，从而保证集群的稳定性和一致性

7.哈希算法，提升读写性能，分散读写压力
 本质上是一种路由寻址算法
 哈希算法：对节点的数量进行取模运算，实现简单，容易理解，但是当需要变更集群数时，大部分的数据都需要迁移，重新映射，数据的迁移成本是非常高
 一致哈希(解决扩缩容)：也是取模运算，对 2^32 进行取模运算，空间组织成一个虚拟的圆环，通过主机名作为参数进行hash，确定其在哈希环上的位置，沿着哈希环顺时针“行走”，遇到的第一节点就是 key 对应的节点
    缺点：节点太少，容易因为节点分布不均匀造成数据访问的冷热不均
 虚拟节点哈希(解决冷热不均): 将哈希环上的位置映射到虚拟节点上

8.Gossip协议实现最终一致性
 集群中只有一个节点也能运行
 Gossip 的三板斧分别是：
  直接邮寄（Direct Mail）：直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传
   缺点：节点可能会因为缓存队列满了而丢数据
  反熵（Anti-entropy）：异步修复实现最终一致性，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异
   实现反熵的时候，主要有推、拉和推拉三种方式
   缺点：通讯成本会很高，可以通过引入校验和（Checksum）等机制，降低需要对比的数据量和通讯消息。节点数量不能太多，
    如果是一个动态变化或节点数比较多的分布式环境（比如在 DevOps 环境中检测节点故障，并动态维护集群节点状态），这时反熵就不适用了
   优化：按照一定顺序来修复节点的数据差异，先随机选择一个节点，然后循环修复，每个节点生成自己节点有、下一个节点没有的差异数据，发送给下一个节点，进行修复。
    因为我们希望能在一个确定的时间范围内实现数据副本的最终一致性。建议你将是否启用反熵功能、执行一致性检测的时间间隔等，做成可配置的，能在不同场景中按需使用
  谣言传播（Rumor mongering）：当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。

9.Quorum NWR算法，自定义一致性
 核心概念
  N 表示副本数，又叫做复制因子，
  W又称写一致性级别（Write Consistency Level），表示成功完成 W 个副本更新，才完成写操作
  R又称读一致性级别（Read Consistency Level），表示读取一个数据对象时需要读 R 个副本
  通过临时调整写入或者查询的方式，当 W + R > N 时，就可以实现强一致性
 使用场景：在 AP 型分布式系统中，Quorum NWR 是通常都会实现的一个功能，用户可以根据业务的特点，灵活地指定一致性级别

10.PBFT算法
 发送的消息通过签名（或消息认证码 MAC）约束恶意节点的行为，采用三阶段协议，基于大多数原则达成一系列值的共识
 HMAC技术：将密钥与消息结合，通过哈希函数（如SHA-256）生成一个固定长度的哈希值，
          哈希值作为消息认证码（MAC），附加在消息上发送给接收方。
          接收方使用相同的密钥和哈希函数重新计算MAC
 客户端联系主节点,主节点通过三阶段协议实现数据一致性,
  Pre-prepare: 主节点构造包含作战指令的预准备消息,广播备份节点，产生n-1条消息
  Prepare: 备份节点不能确认和其他节点接收到的指令是相同的，各备份节点广播包含作战指令的准备消息给其他将军，
   当备份节点收到 2f 个一致的包含作战指令的准备消息后，会进入提交（Commit）阶段，产生n*(n-1)条消息
  Commit：备份节点不能确认其他节点是否收到了 2f 个一致的包含作战指令的准备消息，各备份节点分别广播提交消息给其他节点，当某个将军收到 2f + 1 个验证通过的提交消息后
   表示大部分的将军们已经达成共识，这时可以执行作战指令了。为什么要收2f+1条消息，收f+1行吗？如果设置为f + 1，那么就会被恶意节点干扰。
   比如，在准备和提交阶段，f个恶意节点，都很配合，但在最后，它们却不返回响应消息给客户端，这时客户端可能始终无法收到f + 1个一致的响应消息，也就是达成共识失败，然后客户端不断重试
  最终：客户端收到f+1 个相同的响应（Reply）消息时，判断响应结果是否一致。

  消息复杂度O(n ^ 2)，
  使用场景：在中小型分布式系统中使用，

  如何替换作恶的领导者，通过客户端和各节点完成
   1.客户端超时等待响应，超时后直接发送消息给各个节点，
   2.各节点协商后选举新领导，当一个备份节点，在定时器超时触发了视图变更后，它将暂时停止接收和处理，除了检查点（CHECKPOINT） 、视图变更、新视图之外的消息。
   视图变更：解决主节点故障导致的集群不可用之外，还能解决主节点是恶意节点的问题，避免备份节点长时间阻塞等待客户端请求被执行

  触发视图变更情况
   主节点作恶的情况：
    1.主节点接收到客户端请求后，它不做任何处理，也就是默不作声
    2.主节点接收到客户端请求后，给不同的预准备请求分配不同的序号
    3.主节点只给部分节点发送预准备消息
   备份节点异常
    1.备份节点发送了准备消息后，在约定的时间内未接收到来自其他节点的 2f 个相同的准备消息。
    2.备份节点发送了提交消息后，在约定的时间内未接收到来自其他节点的 2f 个相同的提交消息。
    3.备份节点接收到异常消息，比如视图值、序号和已接受的消息相同，但内容摘要不同。

10.PoW 算法

11.zab协议，Zookeeper Atomic Broadcast原子广播协议
 为什么要不使用paxos、raft算法？
    1.因为paxos的Leader 提出了两个操作 X 和 Y，并分配了 Instance ID 为 101 和 102。如果 Leader 故障，
     新的 Leader 可能会从 Instance ID 101 开始重新提议操作 Z，而不是继续之前的 X 和 Y。最终，系统可能达成共识的顺序是 Z 和 Y，而不是 X 和 Y。
    2.而raft出现的晚。只能领导者写，且日志复制机制

 如何实现操作的顺序性的
  1.写操作必须在主节点，如果客户端访问的节点是备份节点，它会将写请求转发给主节点
  2.主节点接收到写请求后，基于写请求中的指令创建一个提案（Proposal），并使用一个唯一的 事务ZXID(任期编号 epoch, 计数器 counter) 来标识这个提案
  3.创建完提案之后，主节点会基于 TCP 协议，并按照顺序将提案广播到其他节点,保证先发送的消息，会先被收到
  4.主节点接收到指定提案的“大多数”的确认响应后，该提案将处于提交状态（Committed），主节点会通知备份节点提交该提案
  5.主节点或从节点返回响应给客户端，看是哪个角色的节点接受客户端节点

 读操作：
  1.最终一致性读：读操作可以在任何节点上执行
  2.一致性读：在执行读操作前，先执行 sync 命令

 快速领导者选举：在网络通讯正常情况下，各个节点都能够收到其他节点的选票，此时必然会选出最终领导者
  触发条件：检测连接到领导者的读操作超时，变更为候选者状态
  领导者PK即选举出数据最完整的节点，对于每一张接收到选票，节点都需要进行领导者 PK，也就将选票提议的领导者和自己提议的领导者进行比较，找出更适合作为领导者的节点
  1.优先检查任期编号（Epoch），任期编号大的节点作为领导者；
  2.如果任期编号相同，比较事务标识符的最大值，值大的节点作为领导者；
  3.如果事务标识符的最大值相同，比较集群 ID，集群 ID 大的节点作为领导者。
  在某个时刻，有个节点通过大多数节点投票，

  ZAB 定义了 4 种状态，来标识节点的运行状态。
   ELECTION（选举状态）：表明节点在进行领导者选举；
   DISCOVERY（成员发现状态）：表明节点在协商沟通领导者的合法性；
   SYNCHRONIZATION（数据同步状态）：表明集群的各节点以领导者的数据为准，修复数据副本的一致性；
   BROADCAST（广播状态）：表明集群各节点在正常处理写请求。
   重点：只有当集群大多数节点处于广播状态的时候，集群才能提交提案。节点退出跟随者状态时（也就是在进入选举前），所有未提交的提案都会被提交。

 如何从故障中恢复，主节点可以处理写请求
  1.成员发现：目的是确立领导关系。通过跟随者和领导者交互来完成的，目标是确保大多数节点对领导者的领导关系没有异议，也就是确立领导者的领导地位。
      在当选后，领导者会递增自己的任期编号，并基于任期编号值的大小，来和跟随者协商，最终建立领导关系。具体说的话，就是跟随者会选择任期编号值最大的节点，
      作为自己的领导者，而被大多数节点认同的领导者，将成为真正的领导者。
      流程：DISCOVERY状态的从节点发送包含最大任期号消息给leader节点
           leader节点收到消息响应最大任期号+1信息给从节点
           从节点判断领导者的任期编号是否最新，如果不是，就发起新的选举；如果是，跟随者返回 ACKEPOCH 消息给领导者。并设置 ZAB 状态为数据同步
           最后，当领导者接收到来自大多数节点的 ACKEPOCH 消息时，就设置 ZAB 状态为数据同步
  2.数据同步：大多数节点进入广播状态后，领导者会根据跟随者的事务标识符最大值，判断以哪种方式处理不一致数据（有 DIFF增量同步、TRUNC丢弃、SNAP全量同步 这 3 种方式）


12.MySQL XA实现分布式事务
 通过支持 XA 规范的二阶段提交协议，实现了多个 MySQL 数据库操作的事务。
 XA 规范约定的是 DTP 模型中 2 个模块（事务管理器和资源管理器）的通讯方式，DTP 模型（ Distributed Transaction Processing）。
 DTP 各模块的作用。
  AP：应用程序（Aplication Program），一般指事务的发起者（比如数据库客户端或者访问数据库的程序），定义事务对应的操作（比如更新操作 UPDATE executed_table SET status = true WHERE id=100）。
  RM：资源管理器（Resource Manager），管理共享资源，并提供访问接口，供外部程序来访问共享资源，比如数据库，另外 RM 还应该具有事务提交或回滚的能力。
  TM：事务管理器（Transaction Manager），TM 是分布式事务的协调者。TM 与每个 RM 进行通信，协调并完成事务的处理。
 举例：1.AP->TM  发起 全局事务
      2.TM->RM  xa_open建立与资源管理器的会话、xa_start标记事务分支的开头
      3.AP->RM  执行数据库操作，业务逻辑
      4.TM->RM  xa_end标记事务分支的结尾、xa_prepare执行二阶段提交协议的提交请求阶段、xa_commit/xa_rollback执行二阶段提交协议的提交执行阶段、xa_close
 缺点：MySQL XA 性能不高，适合在并发性能要求不高的场景中使用。
     存在单点问题，在第一阶段已经完成了，在第二阶段正准备提交的时候，事务管理器宕机了，相关的资源会被锁定，无法访问。
     只能解决支持XA协议的数据库事务

13.TCC业务层面的分布式事务协,在业务代码中编码实现的
  本质上而言，TCC 是一种设计模式，也就是一种理念，它没有与任何技术（或实现）耦合，也不受限于任何技术，对所有的技术方案都是适用的
 Try 是指预留，它和二阶段提交协议中，提交请求阶段的操作类似，具体来说就是，系统会将需要确认的资源预留、锁定，确保确认操作一定能执行成功。
 Confirm 是指确认，它呢和二阶段提交协议中，提交执行阶段的操作类似，具体是指，系统将最终执行的操作。
 Cancel 是指撤销，比较像二阶段提交协议中的回滚操作，具体指系统将撤销之前预留的资源，也就是撤销已执行的预留操作对系统产生的影响。











