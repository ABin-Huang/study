nacos架构

Nacos提供了SDK和Open API两种形式来实现服务注册。

Provider APP：服务提供者
Consumer APP：服务消费者
Name Server：通过VIP（Virtual IP）或DNS的方式实现Nacos高可用集群的服务路由
Nacos Server：Nacos服务提供者，里面包含的Open API是功能访问入口，
Conig Service、Naming Service 是Nacos提供的配置服务、命名服务模块。
Consitency Protocol是一致性协议，用来实现Nacos集群节点的数据同步，这里使用的是Raft算法（Etcd、Redis哨兵选举）
Nacos Console：控制台

namespace: <group: service(servicename: instance)>

基本流程
1.服务注册
2.服务获取
3.动态感知服务提供者状态（心跳检测5秒一次，15秒不健康，30移除）
4.消费端实时获取服务提供者最新状态（定时拉取，主动通知udp协议）
5.动态dns
6.同步数据其他节点

临时节点：distro协议
持久节点：raft协议

raft:
Leader：所有请求的处理者，Leader副本接受client的更新请求，本地处理后再同步至多个其他副本；
Follower：请求的被动更新者，从Leader接受更新请求，然后写入本地日志文件
Candidate：如果Follower副本在一段时间内没有收到Leader副本的心跳，则判断Leader可能已经故障，此时启动选主过程，此时副本会变成Candidate状态，直到选主结束。

nacos集成到spring-cloud
1.spring-cloud提供ServiceRegistry，
2.META-INF/spring.factories包含AutoServiceRegistrationAutoConfiguration类，
3.NacosAutoServiceRegistration继承了AbstractAutoServiceRegistration
4.AbstractAutoServiceRegistration实现了EventListener接口【Nacos是通过Spring的事件机制注册springCloud】
5.AbstractAutoServiceRegistration实现了onApplicationEvent抽象方法,并且监听WebServerInitializedEvent事件(当Webserver初始化完成之后) ,

高性能：注册节点时（采用异步加阻塞队列）

dubbo spi

1.0版本缺点
1.心跳多【接口级服务较多时，心跳及配置元数据的轮询数量众多，导致集群TPS很高，系统资源高度空耗】
2.无效查询多【UDP不可靠，客户端每隔一段时间获取最新服务列表，客户端规模上升，大多数服务列表其实不会频繁改变，造成无效查询】
3.心跳续约感知变化慢【默认为15s，时延较长，时效性差。若改短超时时间，当网络抖动时，会频繁触发变更推送】
4.连接消耗大【HTTP短连接模型，每次客户端请求都会创建和销毁TCP链接，TCP协议销毁的链接状态是WAIT_TIME，完全释放还需要一定时间】
5.频繁GC【HTTP短连接阻塞模型来模拟长连接通信，每30秒需要进行一次请求和数据的上下文切换，每一次切换都有引起造成一次内存浪费，从而导致服务端频繁GC】


2.0版本
改进
1.增加了对长连接的支持，gRPC 和 Rsocket 实现了长连接 RPC 调用和推送能力。不需定时发送实例心跳
2. TCP连接断开可以被快速感知到，提升反应速度。
3.长连接的流式推送，比UDP更加可靠；nio的机制具有更高的吞吐量，而且由于可靠推送，
   可以加长客户端用于对账服务列表的时间，甚至删除相关的请求。重复的无效QPS可以大幅降低。
4.长连接避免频繁连接开销，可以大幅缓解TIME_ WAIT问题。，解决频繁GC


缺点
1长连接需要维护连接状态
2.数据由无状态变为有状态
3.RPC观测性不如Http

================nacos动态配置实时刷新原理=========================

临时实例和永久实例是什么？有什么区别？
答案：临时实例--保存服务端内存(服务注册表)，不会持久化
   永久实例--保存服务注册表并持久化，服务实例下线或异常，将其健康状态设为不健康，不会从注册表剔除
   适用场景：临时适用业务服务吗，永久适用中间件等运维服务，如redis，mysql可以通过SDK手动注册
   1.x版本：临时和永久说的是服务实例
   2.x版本：临时和永久说的是服务(实例的集群)，如mysql，每个服务实例肯定都是永久的

服务实例是如何注册到服务端的？
答案：注册中心的客户端SDK或者控制台
 1.x版本：通过http接口注册
 2.x版本：使用gRPC长连接，提升性能。因为Http请求会频繁创建和销毁连接。
   会将服务实例信息存储到客户端缓存，供Redo操作,当因为异常原因导致连接断开，客户端重建连接，
   将服务实例重新注册服务端，还有服务订阅之类的操作。本质是个定时任务，默认每3s执行一次

服务实例和服务端之间是如何保活的？
答案： 临时实例通过心跳机制实现保活，服务实例向服务端发送请求
 nacos 1版本：通过客户端和服务端各存在的一个定时任务来完成。
   1.客户端在服务注册时，发现是临时实例，开启一个5s执行一次的定时任务(构建一个Http请求,将实例的信息，发送到服务端)。
   2.Nacos服务端开启一个定时任务，默认5s执行一次，检查服务实例最后一次心跳的时间，也就是客户端最后一次发送Http请求的时间
      心跳时间超过15s标记成不健康，超过30s，直接把服务从服务注册表中剔除

 nacos 2版本：
      1.客户端使用gRPC长连接来保活，当连接断开，nacos服务端将服务实例从服务注册表中提出剔除。客户端会定时通过这个长连接向服务端发送心跳，默认心跳间隔3秒。当因为异常原因导致连接断开，客户端重建连接，将服务实例重新注册服务端，还有服务订阅之类的操作。
      2.服务端的一个主动检测机制，启动一个定时任务，默认每隔3s执行一次，检查超过20s没有发送请求数据的连接，
   向这个连接对应的客户端发送一个请求，如果请求不通或者响应失败，此时服务端会认为与客户端的连接异常，将服务实例从服务注册表中剔除

   永久实例通过健康检查保活，服务端主动向服务实例发送请求，去探测服务实例是否活着
 nacos服务端创建一个健康检查任务，每次执行时间间隔会在2000~7000毫秒之间，根据设置的健康检查的方式执行不同的逻辑，有TCP、Http、Mysql
  TCP(默认实现)：根据服务实例的ip和端口判断是否能连接成功，如果连接成功，就认为健康，反之就任务不健康
  HTTP：向服务实例的ip和端口发送一个Http请求，请求路径是需要设置的，如果能正常请求，说明实例健康，反之就不健康
  MySQL：一种特殊的检查方式，他可以执行下面这条Sql来判断数据库是不是主库


服务订阅是如何实现的Nacos？
答案：Nacos通过主动查询、服务订阅实现
   主动查询：客户端主动向服务端查询需要关注的服务实例，也就是拉（pull）的模式。
      nacos1版本发送Http请求去查询服务实例
      nacos2版本发送gRPC请求去查询服务实例
   服务订阅(默认)：客户端向服务端发送一个订阅服务的请求，当被订阅的服务有信息变动就会主动将服务实例的信息推送给订阅的客户端，
   本质就是推（push）模式
      nacos1版本：  
        1.客户端创建UDP Socket来接收服务端推送的数据，主动查询服务端时也会将UDP Socket传给服务端，将订阅服务信息保存到缓存。
          会为这次订阅开启一个不定时执行的任务，主动查询服务实例。是因为UDP通信不稳定，弥补最新数据不能推送成功
        2.服务端接收到这个UDP端口后，后续就通过这个端口给客户端推送服务实例数据
      nacos2版本：只支持订阅临时服务
         1.换成了gRPC长连接的方式，抛弃了1.x的UDP做法。
         2.客户端默认关闭不定时任务，因为有redo操作，确保能拿到最新的实例信息

集群间数据是如何同步的？CP还是AP？
答案：使用AP还是CP得取决于Nacos内部的具体功能
 以服务注册举例来说，对于临时实例来说，Nacos会优先保证可用性，也就是AP
   阿里自研的Distro协议
   1.每个节点平等，都有读写功能
   2.节点数据同步机制
      --失败重试机制，每隔3s重试一次，直到成功 
      --定时对比机制，定时向所有的其它服务节点发送一些认证的请求，判断服务实例的版本号是否推送数据
对于永久实例，Nacos会优先保证数据的一致性，也就是CP，基于Raft算法


Nacos的数据模型是什么样的？
