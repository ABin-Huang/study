问题：如何实现隔离级别（读未提交，读已提交，可重复读，串行化）
答案：1）读已提交（记录锁）/可重复读（记录锁+间隙锁）：MVVC
2）串行化：使用排他锁（exclusive lock）来锁定事务正在读取或修改的数据，防止其他事务对同一数据进行并发操作。

问题：可重复读的底层原理（执行第一个查询语句后创建read view）,很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：
答案：
    1）针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，
事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，
是查询不出来这条数据的，所以就很好了避免幻读问题。
    2）针对当前读（select ... for update 、update、deleter、insert等语句），是通过 next-key lock（记录锁+间隙锁--锁定范围，如使用范围查询，若其他事务想插入，会生成插入意向锁并阻塞）
方式解决了幻读，
因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，
那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

具体功能：A创建事务，B随后创建事务，A修改值，B读取值，当A提交完事务，B读取的还是原来的值，并不是A修改后的值。
因为可重复读隔离级别在事务期间读到的记录都是事务启动前的记录（会通过roll_pointer查找undo log，多个版本记录以链表的方式串联起来）

问题：Read View 在 MVCC 里如何工作的？
答案：Read View 中四个字段以及聚簇索引记录中两个跟事务有关的隐藏列
1）m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。
2）min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。
3）max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；
4）creator_trx_id ：指的是创建该 Read View 的事务的事务 id。

1）.trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；
2）.roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。

问题：读提交是如何工作的
答案：在每次读取数据时，都会生成一个新的 Read View。



问题：mysql的锁
1）全局锁：用于全库逻辑备份，此时数据库只可读。
优化方法：在可重复读的隔离级别备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。
2）表级锁：
表锁：锁表，只提供读
元数据锁（MDL，防止其他线程对这个表结构做了变更）：1.对一张表进行 CRUD 操作时，加的是 MDL 读锁；  2.对一张表做结构变更操作的时候，加的是 MDL 写锁；
意向锁（只会与表锁冲突，意向锁的目的是为了快速判断表里是否有记录被加锁）： InnoDB 引擎的表里对某些记录加上「共享锁」/「独占锁」之前，要先在表级别加上一个「意向共享锁」/「意向独占锁」；
AUTO-INC 锁；
3）行级锁
Record Lock（ S 锁和 X 锁），记录锁，也就是仅仅把一条记录锁上；
Gap Lock（只存在于可重复读隔离级别，解决幻读），间隙锁，锁定一个范围，但是不包含记录本身；
Next-Key Lock（临键锁）：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
插入意向锁（特殊的间隙锁，属于行级别锁）：一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁


问题：innodb怎么加行级锁？
答案：加锁的对象是索引，加锁的基本单位是 next-key lock。在一些场景下会退化成记录锁或间隙锁（在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁）
加锁规则：除了在二级索引加，还会在主键索引加

问题：如何避免全表扫描
答案：执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了。

segment，region，page，raw