TCP/IP协议
1.应用层，传输层（TCP，UDP），网际层（IPV4，6），网络接口层

SYN：建立连接
FIN：关闭连接
ACK：响应
PSH：有DATA数据传输
RST：连接重置

网络连接状况  ss命令
netstat -alepn

lsof找出进程
1.lsof /var/run/docker.sock
2.lsof -i :8080

抓包利器:tcpdump

1.如何产生TIME_WAIT 的状态
答案：发起连接断开的一方会有一段时间处于 TIME_WAIT 的状态

2.TIME_WAIT状态有什么作用
答案：1.确保最后的 ACK 能让被动关闭方接收，从而帮助被动方正常关闭。

3.为什么是2MSL
答案：1.为了确保被动方正确关闭连接，因为主动发发送ask的时间为MSL，被动方重传fin时间为MSL。
     2.确保了所有可能存在的旧数据包都被处理或丢弃。数据应该在进入time_wait前被处理，如果进入time_wait后，数据应该被抛弃，
     等待2MSL可以确保所有数据被抛弃。新连接就不会受到旧数据包的影响，从而避免了数据混乱和潜在的安全问题。

4.如何优化TIME_WAIT 状态
答案：1.net.ipv4.tcp_max_tw_buckets。将系统值调小。这个值默认为 18000，
当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置，并且只打印出警告信息。
    （1.上述参数设置不当而频繁发生连接被非正常断开的情况，那么应用程序的行为可能会变得不稳定甚至出现故障，例如数据库连接突然断开、HTTP请求失败等
      2.尽管减少了处于 TIME_WAIT 状态的连接数，但是这种做法增加了网络中出现重复SYN-ACK和RST包的可能性
      3.TIME_WAIT 的存在有助于防范某些类型的攻击（比如针对半开放连接的攻击））

  2.调低 TCP_TIMEWAIT_LEN（减少保持的时间），重新编译系统
 （数据包混乱：如果新的连接复用了之前关闭的连接的四元组（源 IP、源端口、目的 IP、目的端口），而旧的数据包仍然在网络中延迟到达，就可能发生数据混淆。
  网络稳定性：TIME_WAIT 状态是确保所有已发送的数据都被接收方正确接收的重要机制。过早地结束这个状态可能会导致一些未预见的问题。）

  3.net.ipv4.tcp_tw_reuse（可以复用处于 TIME_WAIT 的套接字为新的连接所用）,需要打开对 TCP 时间戳的支持，即net.ipv4.tcp_timestamps=1（默认即为 1）
 (1.只适用于连接发起方（C/S 模型中的客户端）
  2.对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用)

  理由：TCP 协议也在与时俱进，RFC 1323 中实现了 TCP 拓展规范，以便保证 TCP 的高可用，并引入了新的 TCP 选项，
      两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，
      我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。
  慎用：当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉！！！

5.close和shutdown方法
答案：1.close会关闭套接字连接和资源
2.shutdown可以控制读或写套接字的关闭，可控的保证数据被正确发送和接受

6.如何知道连接是有效的（保活时间、保活时间间隔和保活探测次数）
答案：1.TCP Keep-Alive 选项（定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，
    每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，
    则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。
    2.自定义心跳机制，模仿TCP Keep-Alive，使用心跳包和select函数


7.客户端保活和服务端保活
答案：1。服务器端要探活client来保证自己不会维护无效连接。
    2.客户端来探活保持自己是不是可以持续申请资源。

8.发送窗口，接受窗口，拥塞窗口实现动态数据传输
答案：1.发送窗口反应了作为单 TCP 连接、点对点之间的流量控制模型，它是需要和接收端一起共同协调来调整大小的
    2.拥塞窗口则是反应了作为多个 TCP 连接共享带宽的拥塞控制模型，它是发送端独立地根据网络状况来动态调整
    发送窗口用来控制发送和接收端的流量；阻塞窗口用来控制多条连接公平使用的有限带宽。

    解决问题
    1.糊涂窗口综合症--在接收端进行优化，接收端不能在接收缓冲区空出一个很小的部分之后，就向发送端发送窗口更新通知，
     而是需要在自己的缓冲区大到一个合理的值之后，再向发送端发送窗口更新通知。这个合理的值，由对应的 RFC 规范定义。
    2.Nagle 算法--限制大批量的小数据包同时发送，它提出，在任何一个时刻，未被确认的小数据包不能超过一个。这里的小数据包，
     指的是长度小于最大报文段长度 MSS 的 TCP 分组。需要发送端把接下来连续的几个小数据包存储起来将数据一次性发送出去
    3.延时 ACK--收到数据后并不马上回复，等到有数据需要发送给对端时，将累计的 ACK捎带一并发送出去。
     延时 ACK 机制，不会无限地延时下去

9.UDP也可以是“已连接”
答案：客户端使用connect函数绑定服务端的地址和端口。
优点：1.不用每次发送数据都进行连接套接字，断开套接字操作。
    2.程序可以快速获取异步错误信息的通知。操作系统内核从容建立了（UDP 套接字——目的地址 + 端口）之间的映射关系，
    当收到一个 ICMP 不可达报文时，操作系统内核可以从映射表中找出是哪个 UDP 套接字拥有该目的地址和端口

10.TCP服务经常出现“地址已经被使用”
答案：服务主动关闭连接，会进入time_wait状态，此时重启服务，由于旧连接未关闭。
使用SO_REUSEADDR 套接字选项，可以重用端口。序列化比time_wait大，时间戳比较大。

11.读缓冲的作用
答案：1. 提高 I/O 性能
   批量读取：通过一次性读取大量数据到缓冲区，可以减少 I/O 操作的次数。每次 I/O 操作都有一定的开销（如系统调用开销、磁盘寻道时间等），批量读取可以显著提高 I/O 性能。
   减少上下文切换：频繁的 I/O 操作会导致更多的上下文切换，这会消耗 CPU 时间。使用读缓冲可以减少上下文切换的次数，从而提高整体性能。
   2. 平滑数据流
   数据平滑：在网络通信中，数据包可能以突发的方式到达。读缓冲可以平滑数据流，使得应用程序可以以更稳定的速度处理数据。
   避免数据丢失：在高速数据流的情况下，如果没有足够的缓冲区来存储数据，可能会导致数据丢失。读缓冲可以确保数据不会因为处理速度跟不上而丢失。
   3. 简化编程模型
   统一接口：读缓冲提供了一个统一的接口，使得应用程序可以以相同的方式处理来自不同来源的数据。无论数据是来自文件、网络还是其他设备，都可以通过读缓冲进行统一处理。
   异步处理：读缓冲支持异步 I/O 操作，允许应用程序在等待 I/O 完成时继续执行其他任务。当数据准备好时，应用程序可以通过回调或其他机制进行处理。
   4. 错误处理和恢复
   数据完整性：读缓冲可以帮助检测和处理传输中的错误。例如，在网络通信中，如果某个数据包损坏或丢失，可以通过读缓冲来重新请求数据。
   断点续传：在文件传输过程中，如果连接中断，读缓冲可以记录已经接收的数据，并在连接恢复后继续从断点处开始传输。
   5. 资源管理
   内存管理：读缓冲可以有效地管理内存资源。通过预分配一定大小的缓冲区，可以避免频繁的内存分配和释放操作，减少内存碎片。
   带宽利用：在网络通信中，读缓冲可以更好地利用带宽。通过批量读取数据，可以充分利用网络带宽，减少空闲时间。
   6. 协议处理
   协议解析：在网络通信中，读缓冲可以用来存储接收到的数据，以便进行协议解析。例如，在 HTTP 协议中，读缓冲可以存储完整的请求或响应头信息，以便应用程序进行解析和处理。
   消息边界：对于基于消息的协议（如 TCP 套接字通信），读缓冲可以帮助识别消息边界，确保完整的消息被正确处理。


12.多路复用技术
  1.select：最差，现在连接数，最大1024
  2.poll：第二好,条件触发
  3.epoll：性能最好,条件触发（传感器），边缘触发（只在状态变化时通知一次），通常在键盘按键，计数器等需要高实时性和短事件场景使用

  poll和epoll性能分析：epoll返回的是有事件发生的数组,而poll返回的是准备好的个数,每次poll函数返回都要遍历注册的描述符结合数组，
    尤其是数量越大遍历次数就越多

13.如何解决C10k问题
答案：从两个层次处理：1.应用程序和操作系统的交互，应用程序如何感知I/O事件
        2.应用程序如何使用进程或线程处理I/O事件

   由上述两个层次引发出几个模型
   1.阻塞I/O+进程：主进程监听套接字监听IO事件，子进程处理IO事件（子进程会copy主进程的数据，如地址空间、打开的文件描述符、程序计数器等，执行代码等）
   2.阻塞I/O+线程池：同进程的所有线程共享进程的整个虚拟地址空间，包括代码、数据、堆、共享库等
   3.I/O多路复用，单线程（事件驱动模型reactor）+业务线程池，reactor负责连接建立和分发I/O事件任务，业务线程池负责业务处理
   4.主-从reactor模式（优化3）+业务线程池：主反应堆线程只负责分发 Acceptor 连接建立，已连接套接字上的 I/O 事件交给 sub-reactor 负责分发
   5.

netty选子线程是两种算法，都是有个原子自增计数，如果线程数不是2的幂用取模，如果是就是按位与线程数减一

socketpair 函数的主要特点：

进程间通信：socketpair 创建的套接字对可以用于不同进程之间的通信，这种通信方式类似于使用网络套接字进行通信，但是不涉及网络协议栈，而是直接在内核中进行数据传输。
全双工通信：socketpair 创建的套接字对支持全双工通信，这意味着每个套接字都可以同时进行读取和写入操作，从而实现进程间的双向通信。
用途：socketpair 在一些场景下非常有用，比如父子进程之间的通信、进程间的管道通信等。通过 socketpair 创建的套接字对可以实现高效的进程间通信，避免了数据复制和内核空间和用户空间之间的频繁切换。

14.epoll三个步骤
答案：1.创建epoll实例（epoll_create1）。 2.向epoll实例添加/修改/删除文件描述符（epoll_ctl）。3.等待并处理事件（epoll_wait()）